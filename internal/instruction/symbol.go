package instruction

import (
	"c0_compiler/internal/cc0_error"
)

type Symbol struct {
	Address    int
	FnInfo     *Fn
	IsCallable bool
	IsConstant bool
	Kind       int
	Name       string
}

type SymbolTable struct {
	Constants       *[]Constant
	Parent          *SymbolTable
	RelatedFunction *Fn
	Symbols         map[string]*Symbol
	fnCount         int
}

func (st SymbolTable) HasDeclared(name string) bool {
	_, ok := st.Symbols[name]
	return ok
}

func (st *SymbolTable) nextFnCount() (res int) {
	res = st.fnCount
	st.fnCount++
	return
}

func (st SymbolTable) GetSymbolNamed(name string) *Symbol {
	currentTable := &st
	for {
		if sb, ok := currentTable.Symbols[name]; ok {
			return sb
		}
		if currentTable.Parent != nil {
			currentTable = currentTable.Parent
		} else {
			return nil
		}
	}
}

func (st SymbolTable) GetAddressOf(symbol string) int {
	sb := st.GetSymbolNamed(symbol)
	if sb == nil {
		return -1
	}
	return sb.Address
}

func (st SymbolTable) RemoveConstantNamed(name string) *Error {
	if !st.HasDeclared(name) || !st.Symbols[name].IsConstant {
		return cc0_error.Of(cc0_error.Bug)
	}
	st.RelatedFunction.emptyMemorySlots.Push(st.Symbols[name].Address)
	delete(st.Symbols, name)
	return nil
}

func (st SymbolTable) AddAConstant(name string, kind int) *Error {
	if st.HasDeclared(name) {
		return cc0_error.Of(cc0_error.RedeclaredAnIdentifier)
	}
	st.Symbols[name] = &Symbol{
		Address:    st.RelatedFunction.NextMemorySlot(kind),
		FnInfo:     nil,
		IsCallable: false,
		IsConstant: true,
		Kind:       kind,
		Name:       name,
	}
	return nil
}

func (st SymbolTable) AddAVariable(name string, kind int) *Error {
	if st.HasDeclared(name) {
		return cc0_error.Of(cc0_error.RedeclaredAnIdentifier)
	}
	st.Symbols[name] = &Symbol{
		Address:    st.RelatedFunction.NextMemorySlot(kind),
		FnInfo:     nil,
		IsCallable: false,
		IsConstant: false,
		Kind:       kind,
		Name:       name,
	}
	return nil
}

func InitSymbolTable(parent *SymbolTable, fi *Fn) *SymbolTable {
	result := &SymbolTable{
		Constants:       &[]Constant{},
		Symbols:         map[string]*Symbol{},
		Parent:          parent,
		RelatedFunction: fi,
	}
	fi.RelatedSymbolTable = result
	return result
}

func (st *SymbolTable) AppendChildSymbolTable(relatedFunction *Fn) *SymbolTable {
	return InitSymbolTable(st, relatedFunction)
}

// Functions generated by this function would not have addresses. Their addresses should be reassigned by the assembler.
func (st *SymbolTable) AddAFunction(name string, returnType int, fn *Fn) *Error {
	if st.HasDeclared(name) {
		return cc0_error.Of(cc0_error.RedeclaredAnIdentifier)
	}
	st.Symbols[name] = &Symbol{
		Address:    st.nextFnCount(),
		FnInfo:     fn,
		IsCallable: true,
		IsConstant: true,
		Kind:       returnType,
		Name:       name,
	}
	return nil
}

func (st *SymbolTable) GetLevelDiff(name string) int {
	if _, ok := st.Symbols[name]; ok {
		return 0
	}
	return 1
}

var emptyConstantSlot = 0

// This is almost always only received by the global symbol table.
func (st *SymbolTable) AddALiteral(kind int, value interface{}) (address int) {
	address = emptyConstantSlot
	emptyConstantSlot++
	*st.Constants = append(*st.Constants, Constant{
		Kind:    kind,
		Value:   value,
		Address: -address,
	})
	return
}
