package instruction

import (
	"c0_compiler/internal/cc0_error"
)

type Symbol struct {
	Kind       int
	IsConstant bool
	IsCallable bool
	Address    int
	Appendix   interface{}
}

type SymbolTable struct {
	Symbols         map[string]Symbol
	Parent          *SymbolTable
	RelatedFunction *Fn
}

func (st SymbolTable) HasDeclared(name string) bool {
	_, ok := st.Symbols[name]
	return ok
}

func (st SymbolTable) GetSymbolNamed(name string) *Symbol {
	currentTable := &st
	for {
		if sb, ok := currentTable.Symbols[name]; ok {
			return &sb
		}
		if currentTable.Parent != nil {
			currentTable = currentTable.Parent
		} else {
			return nil
		}
	}
}

func (st SymbolTable) GetAddressOf(symbol string) int {
	sb := st.GetSymbolNamed(symbol)
	if sb == nil {
		return -1
	}
	return sb.Address
}

func (st SymbolTable) RemoveConstantNamed(name string) *Error {
	if !st.HasDeclared(name) || !st.Symbols[name].IsConstant {
		return cc0_error.Of(cc0_error.Bug)
	}
	st.RelatedFunction.emptyMemorySlots.Push(st.Symbols[name].Address)
	delete(st.Symbols, name)
	return nil
}

func (st SymbolTable) AddAConstant(name string, kind int) *Error {
	if st.HasDeclared(name) {
		return cc0_error.Of(cc0_error.RedeclaredAnIdentifier)
	}
	st.Symbols[name] = Symbol{
		Kind:       kind,
		IsConstant: true,
		IsCallable: false,
		Address:    st.RelatedFunction.NextMemorySlot(),
		Appendix:   nil,
	}
	return nil
}

func (st SymbolTable) AddAVariable(name string, kind int) *Error {
	if st.HasDeclared(name) {
		return cc0_error.Of(cc0_error.RedeclaredAnIdentifier)
	}
	st.Symbols[name] = Symbol{
		Kind:       kind,
		IsConstant: false,
		IsCallable: false,
		Address:    st.RelatedFunction.NextMemorySlot(),
		Appendix:   nil,
	}
	return nil
}

func InitSymbolTable(parent *SymbolTable, fi *Fn) *SymbolTable {
	return &SymbolTable{
		Symbols:         map[string]Symbol{},
		Parent:          parent,
		RelatedFunction: fi,
	}
}

func (st *SymbolTable) AppendChildSymbolTable(relatedFunction *Fn) *SymbolTable {
	return &SymbolTable{
		Symbols:         map[string]Symbol{},
		Parent:          st,
		RelatedFunction: relatedFunction,
	}
}

// Functions generated by this function would not have addresses. Their addresses should be reassigned by the assembler.
func (st *SymbolTable) AddAFunction(name string, returnType int) *Error {
	if st.HasDeclared(name) {
		return cc0_error.Of(cc0_error.RedeclaredAnIdentifier)
	}
	st.Symbols[name] = Symbol{
		Kind:       returnType,
		IsConstant: true,
		IsCallable: true,
		Address:    0,
		Appendix:   nil,
	}
	return nil
}
