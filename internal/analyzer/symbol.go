package analyzer

import (
	"c0_compiler/internal/vm"
	"container/heap"
)

type symbol struct {
	kind       c0Type
	isConstant bool
	isCallable bool
	address    int
	appendix   interface{}
}

type functionInfo struct {
	instructions *[]string
	parameters   *[]string
	emptySlots   *PriorityQueue
}

type symbolTable struct {
	symbols         map[string]symbol
	parent          *symbolTable
	relatedFunction *functionInfo
}

func (fi *functionInfo) nextSlot() (slot int) {
	queue := fi.emptySlots
	slot = queue.Pop().(int)
	if queue.Len() == 0 {
		queue.Push(slot + 1)
	}
	return
}

func (st symbolTable) hasDeclared(name string) bool {
	_, ok := st.symbols[name]
	return ok
}

// Functions generated by this function would not have addresses. Their addresses should be reassigned by the assembler.
func addAFunction(name string, returnType c0Type) *Error {
	if globalSymbolTable.hasDeclared(name) {
		return errorOf(RedeclaredAnIdentifier)
	}
	globalSymbolTable.symbols[name] = symbol{
		kind:       returnType,
		isConstant: true,
		isCallable: true,
		address:    0,
		appendix:   nil,
	}
	return nil
}

// TODO: Add an staging area for instructions per analysis function
func (sb symbol) addAnInstruction(instruction string) {
	sb.appendix.(functionInfo).addAnInstruction(instruction)
}

func (fi functionInfo) addAnInstruction(instruction string) {
	*fi.instructions = append(*fi.instructions, instruction)
}

func (fi functionInfo) addAnInstructionWithNoOperands(code int) {
	fi.addAnInstruction(vm.InstructionWithNoOperands(code))
}

func (fi functionInfo) addAnInstructionWithOneOperand(code, operand int) {
	fi.addAnInstruction(vm.InstructionWithOneOperand(code, operand))
}

func (fi functionInfo) addAnInstructionWithTwoOperands(code, operand1, operand2 int) {
	fi.addAnInstruction(vm.InstructionWithTwoOperands(code, operand1, operand2))
}

func (st symbolTable) getSymbol(symbol string) *symbol {
	currentTable := &st
	for {
		if sb, ok := currentTable.symbols[symbol]; ok {
			return &sb
		}
		if currentTable.parent != nil {
			currentTable = currentTable.parent
		} else {
			return nil
		}
	}
}

func (st symbolTable) getAddressOf(symbol string) int {
	sb := st.getSymbol(symbol)
	if sb == nil {
		return -1
	}
	return sb.address
}

func (st symbolTable) removeConstant(name string) *Error {
	if !st.hasDeclared(name) || !st.symbols[name].isConstant {
		return errorOf(Bug)
	}
	st.relatedFunction.emptySlots.Push(st.symbols[name].address)
	delete(st.symbols, name)
	return nil
}

func (st symbolTable) addAConstant(name string, kind c0Type) *Error {
	if st.hasDeclared(name) {
		return errorOf(RedeclaredAnIdentifier)
	}
	st.symbols[name] = symbol{
		kind:       kind,
		isConstant: true,
		isCallable: false,
		address:    st.relatedFunction.nextSlot(),
		appendix:   nil,
	}
	return nil
}

func (st symbolTable) addAVariable(name string, kind c0Type) *Error {
	if st.hasDeclared(name) {
		return errorOf(RedeclaredAnIdentifier)
	}
	// TODO: assign proper address for variables
	st.symbols[name] = symbol{
		kind:       kind,
		isConstant: false,
		isCallable: false,
		address:    st.relatedFunction.nextSlot(),
		appendix:   nil,
	}
	return nil
}

func initSymbolTable(parent *symbolTable, fi *functionInfo) *symbolTable {
	return &symbolTable{
		symbols:         map[string]symbol{},
		parent:          parent,
		relatedFunction: fi,
	}
}

func initFunctionInfo() (res *functionInfo) {
	res = &functionInfo{
		instructions: &[]string{},
		parameters:   &[]string{},
		emptySlots:   &PriorityQueue{0},
	}
	heap.Init(res.emptySlots)
	return
}

func createChildSymbolTableFor(parent *symbolTable, relatedFunction *functionInfo) *symbolTable {
	return &symbolTable{
		symbols:         map[string]symbol{},
		parent:          parent,
		relatedFunction: relatedFunction,
	}
}
